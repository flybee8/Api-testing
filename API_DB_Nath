Created on Feb 20, 2017
@author: diptanun'''#!/ms/dist/python/PROJ/core/2.7.9-0-64/bin/pythonimport platformimport ms.versionms.version.addpkg("requests", "2.7.0")ms.version.addpkg("requests-kerberos", "0.5-ms2")ms.version.addpkg("kerberos", "1.1.5")ms.version.addpkg("ms.modulecmd", "1.0.4")ms.version.addpkg('python', 'ng-trunk', meta='ets')ms.version.addpkg("requests", "2.7.0")ms.version.addpkg("requests-kerberos", "0.5-ms2")ms.version.addpkg("kerberos", "1.1.5")ms.version.addpkg("ms.modulecmd", "1.0.4")ms.version.addpkg('python', 'ng-trunk', meta='ets')ms.version.addpkg("pandas","0.19.0-py27-64")ms.version.addpkg("numpy","1.11.2-py27-64")ms.version.addpkg("dateutil","2.5.2-py34")ms.version.addpkg("pandas-highcharts","0.5.2")ms.version.addpkg("pandas-datareader","0.2.1")ms.version.addpkg("xlrd","1.0.0-py34")ms.version.addpkg("dicttoxml","1.7.4")ms.version.addpkg("xmltodict", "0.9.0")ms.version.addpkg("html", "1.16")ms.version.addpkg("htmlpy", "0.04")from ets.testplan import test_planfrom ets.testcases.multitest import MultiTestfrom ets.testcases.multitest.util import *from termcolor import coloredfrom requests_kerberos import HTTPKerberosAuthfrom datetime import datetimefrom ets.testcases.multitest.suite import testsuite, testcasefrom ets.couch import testdbfrom email.mime.text import MIMETextfrom email.mime.multipart import MIMEMultipartfrom email.MIMEBase import MIMEBasefrom email import Encodersfrom pandas import *from xml.etree import ElementTreefrom pandas import compatfrom math import isnanimport requestsimport kerberosimport jsonimport xmltodict,json,pprintimport osimport globimport reimport jsonimport ConfigParserimport sysimport timeimport astimport loggingimport logging.handlersimport smtplibimport urllibimport urllib2import httplibimport urlparseimport argparseimport timeimport numpy as npimport dateutilimport xlrdimport dicttoxmlimport astimport collectionsimport datetimeimport htmlfrom html import HTMLimport subprocessfrom subprocess import check_callimport HTML#from HTML import TableCell,Tablefrom collections import OrderedDictfrom copy import copyfrom filedump import create_excelDb_for_validationfrom filedump import Connect_run_DB_queryreload(sys)sys.setdefaultencoding('utf-8')sys.path.append(os.path.join(os.path.dirname(__file__),'../','etc'))sys.path.append(os.path.join(os.path.dirname(__file__),'../','Config'))path=os.path.abspath(os.path.join(os.path.dirname(__file__), '../', 'etc/Config'))pathDB=os.path.abspath(os.path.join(os.path.dirname(__file__), '../', 'etc/DBTestData'))pathlog=os.path.abspath(os.path.join(os.path.dirname(__file__), '../', 'etc/logs'))
dateTag = datetime.datetime.now().strftime("%Y-%b-%d_%H-%M-%S")logFileName="/results_%s.log" % dateTagLOG_FILENAME=pathlog+logFileName
logging.basicConfig(level=logging.DEBUG,                    format='%(asctime)s%(levelname)-8s%(message)s',                    datefmt='%a,%d %b %Y %H:%M:%S',                    filename=LOG_FILENAME,                    filemode='w')
#Establishing connection to DB servercheck_call(["./initiateDbConnect.sh"])
config = ConfigParser.ConfigParser()####Read DB naming convention from excel and matching to config fileconfigDB = ConfigParser.ConfigParser()configDB.read(path+'/DBsetting.ini')configTime = ConfigParser.ConfigParser()configTime.optionxform = strconfigTime.read(path+'/EpochTimeConverter.ini')

domain,endpoint,method,urlparams,headers,requestbody,grn,DBdata,DBtextfile=None,None,None,None,None,None,None,None,NonetotalApiAttributes,totalDBAttributes=0,0status_code=0global_status_codes={ '203' : 'Non-Authoritative Information','206' : 'Partial Content','300' : 'Multiple Choices','400' : 'Bad Request','401' : 'Unauthrised','403' : 'Forbidden',                      '404' : 'Site Not Found','504' : 'Server Error','500' : 'Server Error'}
#table data list to be used to append Each TestCase resulttable_data = []
TestCaseResult=[]def get_domain_endpoint_method(section):
    try:        domain=config.get(section,'domain')        endpoint=config.get(section,'endpoint')        method=config.get(section,'method')        urlparams=config.get(section,'urlparams')        headers=config.get(section,'headers')        requestbody=config.get(section,'requestbody')        grn=config.get(section,'grn')        DBdata=config.get(section,'DBdata')        DBtextfile=config.get(section,'DBtextfile')    except:        pass    return (domain,endpoint,method,urlparams,headers,requestbody,grn,DBdata,DBtextfile)
def get_TimeConfig(section):    TimeAttributes=[]    try:        data=configTime.items(section)        for key, value in data:            TimeAttributes.append(key)    except:        pass    if TimeAttributes==[]:        return ([])    else:        return (TimeAttributes)
def get_ParentChildConfig(section,name):    parent,child=None,None    try:        data=configDB.get(section,name)        parent,child=str(data).split(',')    except:        pass    if parent==None or child==None or child==''or parent=='':        return (None,None)    else:        return (parent,child)
def get_cookie(grn):    user_agent="Python-requests/%s;%s" % (platform.python_version(),grn)    g_cookies= requests.get("http://krb2sm-v2-prod.ms.com/login", headers={"User-Agent":user_agent},auth=HTTPKerberosAuth())    g_cookies=g_cookies.cookies    return g_cookies
def GET(url=None,urlparams=None,headers =None,grn=None,result=None):    start = time.time()    if urlparams:        try:            g_cookies=get_cookie(grn)            r=requests.get(url,params=ast.literal_eval(urlparams), verify=False,timeout=1.001,headers = headers,cookies=g_cookies)            if r.status_code!=200:                r=requests.get(url,params=ast.literal_eval(urlparams), verify=False,timeout=1.001,headers = headers,auth=HTTPKerberosAuth())        except:            print colored("Element not found",'red')            result.log("API response not recived")    else:        try:            g_cookies=get_cookie(grn)            r=requests.get(url,params=urlparams, verify=False,timeout=1.001,headers = headers,cookies=g_cookies)            if r.status_code!=200:                r=requests.get(url,params=urlparams, verify=False,timeout=1.001,headers = headers,auth=HTTPKerberosAuth())        except:            print colored("Element not found",'red')            result.log("API response not recived")
    responsetime = time.time() - start    #r.connection.close()    if r.status_code!=200:        return None,r.status_code,None,None,responsetime    else:        return r.url,r.status_code,r.json(),r.text,responsetime
def POST(url=None,params=None,headers=None,data=None,grn=None,result=None):    start = time.time()    if urlparams:        try:            g_cookies=get_cookie(grn)            r=requests.post(url,params=ast.literal_eval(params),headers =json.loads(headers) ,cookies=g_cookies,data=data,timeout=1.001)            if r.status_code!=200:                r=requests.post(url,params=ast.literal_eval(params),headers =json.loads(headers) ,data=data,timeout=1.001,auth=HTTPKerberosAuth())        except:            print colored("Element not found",'red')            result.log("API response not recived")    else:        try:            g_cookies=get_cookie(grn)            r=requests.post(url,params=params,headers =json.loads(headers) ,cookies=g_cookies,data=data,timeout=1.001)            if r.status_code!=200:                r=requests.post(url,params=params,headers =json.loads(headers) ,data=data,timeout=1.001,auth=HTTPKerberosAuth())        except:            print colored("Element not found",'red')            result.log("API response not recived")    responsetime = time.time() - start    r.connection.close()    return r.url,r.status_code,r.json(),r.text,responsetime
def to_dict_dropna(data):    return dict((k, v.dropna().to_dict()) for k, v in compat.iteritems(data))

def getDataFromFile(fileName):    with xlrd.open_workbook(fileName) as wb:        # we are using the first sheet here        worksheet = wb.sheet_by_index(0)        # getting number or rows and setting current row as 0 -e.g first        num_rows, curr_row = worksheet.nrows - 1, 0        # retrieving keys values(first row values)        keyValues = [x.value for x in worksheet.row(0)]        # building dict        data = dict((x, []) for x in keyValues)        # iterating through all rows and fulfilling our dictionary        while curr_row < num_rows:            curr_row += 1            for idx, val in enumerate(worksheet.row(curr_row)):                if val.value.strip():                     if val.value=='NULL':val.value='None'                     elif val.value.lower()=='true':val.value='True'                     elif val.value.lower()=='false':val.value='False'                     data[keyValues[idx]].append(val.value)                return data
def ExcelDbDataConversion(ExcelFileName):    dict_new=getDataFromFile(ExcelFileName)    #dict_new=pandas.DataFrame(dict_new)    a=[]    dict_final={}    for k,v in dict_new.items():        #for k1,v1 in v.items():        #a.append(unicode(v))        #a=list(set(a))        v=list(set(v))        v=sorted(v)        dict_final[k]=v        a=[]    return dict_final

def ExcelDbDataConversion_old(ExcelFileName):    xls = ExcelFile(ExcelFileName)    df = xls.parse(xls.sheet_names[0])    df=df.fillna('None')    my_dict=df.to_dict()    raw_data=my_dict    data=pandas.DataFrame(raw_data)    dict_new=to_dict_dropna(data)    a=[]    dict_final={}    for k,v in dict_new.items():        for k1,v1 in v.items():            a.append(unicode(v1))        a=list(set(a))        a=sorted(a)        dict_final[k]=a        a=[]    print dict_final    return dict_final

def getParentChildvalue(myjson,parent,child):    valuesfound=[]    itemsfound=[]    def findkeys(node, kv):        if isinstance(node, list):            for i in node:                for x in findkeys(i, kv):                    yield x        elif isinstance(node, dict):            if kv in node:                yield node[kv]            for j in node.values():                for x in findkeys(j, kv):                    yield x    keyvalues=list(findkeys(myjson,parent))    for items in keyvalues:        try:            dict1=[]            dict1=items.keys()        except:            try:                if isinstance(items, list):                    try:                        dict1=[]                        for length in range(len(items)):                            dict1=items[length].keys()                            itemsfound.append(items[length])                        items=itemsfound                    except:                        pass            except:                pass        try:            if child in dict1:                valuesfound.append(items[child])        except:            for elements in range(len(items)):                if child in items[elements]:                    valuesfound.append(items[elements][child])    #current change in framework doesnt require None to NULL conversion    #valuesfound=['[NULL]' if x==None else x for x in valuesfound]    valuesfound=[str(i).encode("utf-8").decode("utf-8") for i in valuesfound]    return valuesfound
def getTimeAttributeValues(myjson,APIattribute):    valuesfound=[]    def findkeys(node, kv):        if isinstance(node, list):            for i in node:                for x in findkeys(i, kv):                    yield x        elif isinstance(node, dict):            if kv in node:                yield node[kv]            for j in node.values():                for x in findkeys(j, kv):                    yield x    keyvalues=list(findkeys(myjson,APIattribute))    valuesfound=keyvalues    try:        valuesfound=[(time.strftime('%d/%m/%Y %H:%M', time.localtime(x/1000))) for x in valuesfound]    except:        #current change in framework doesnt require None to NULL conversion        #valuesfound=['[NULL]' if x==None else x for x in valuesfound]        valuesfound=[x for x in valuesfound if x]    return valuesfound
#Below method will validate DB data across API response Datadef ValidateDbData(dbDict,response_body,result):    testResult=[]    listA=[]    countAPIAttribute=0    def get_all(myjson, key):        if type(myjson) == str:            myjson = json.loads(myjson)        if type(myjson) is dict:            for jsonkey in myjson:                if type(myjson[jsonkey]) in (list, dict):                    get_all(myjson[jsonkey], key)                elif jsonkey == key:                    #current change in framework doesnt require None to NULL conversion                    #if myjson[jsonkey]==None:                        #myjson[jsonkey]='[NULL]'                    listA.append(myjson[jsonkey])        elif type(myjson) is list:            for item in myjson:                if type(item) in (list, dict):                    get_all(item, key)        return listA    timeAttributes=get_TimeConfig('TimeAttributes')    for keys in dbDict.keys():        parsed_json=get_all(response_body,keys)        #print colored('Start of Test','green')        if not parsed_json:            DBparent,DBchild=get_ParentChildConfig('DBSetting',keys)            if DBparent==None or DBchild==None:                print colored("Response has no such attribute:  "+keys,'red')                testResult.append('Fail')                result.equal(1, description="Response has no such attribute: "+keys) (0, name="")                table=[['DB response','API Response'],                       [dbDict[keys],"Not found"]]                result.tablelog(table, 'Results')            else:                parsed_json=getParentChildvalue(response_body,DBparent,DBchild)                if not parsed_json:                    print colored("Response has no such attribute:  "+keys,'red')                    testResult.append('Fail')                    result.equal(1, description="Response has no such attribute: "+keys) (0, name="")                    table=[['DB response','API Response'],                           [dbDict[keys],"Not found"]]                    result.tablelog(table, 'Results')                else:                    #get API attribute Count                    countAPIAttribute+=1                    listDict=dbDict[keys]                    for items in range(len(listDict)):                        if listDict[items]=='True':listDict[items]=True                        elif   listDict[items]=='False':listDict[items]=False                        else: listDict = [str(i).encode("utf-8").decode("utf-8") for i in listDict]                    for items in range(len(parsed_json)):                        if parsed_json[items]=='True':parsed_json[items]=True                        elif   parsed_json[items]=='False':parsed_json[items]=False                        elif  parsed_json[items]==True:pass                        elif  parsed_json[items]==False:pass                        else: parsed_json = [str(i).encode("utf-8").decode("utf-8") for i in parsed_json]                    #parsed_json=[str(i).encode("utf-8").decode("utf-8") for i in parsed_json]                    c=[x for x in parsed_json if x in list(listDict)]                    compare = lambda x, y: collections.Counter(x) == collections.Counter(y)                    if compare(parsed_json, c):                        pass                    else:                        not_c=[x for x in parsed_json if x not in list(listDict)]                        print colored(('not equal','Attribute Name:'+keys,list(set(not_c))),'red')                    result.equal(True, description="Expected DB Compare for Attribute: "+keys) (compare(parsed_json, c), name="Actual Db Compare")                    if not compare(parsed_json, c):                        testResult.append('Fail')                    table=[['DB response','API Response'],                       [listDict,parsed_json]]                    result.tablelog(table, 'Results')            c=[]            listA=[ ]        elif keys in timeAttributes:            parsed_json=getTimeAttributeValues(response_body,keys)
            if not parsed_json:                print colored("Response has no such attribute:  "+keys,'red')                testResult.append('Fail')                result.equal(1, description="Response has no such attribute: "+keys) (0, name="")                table=[['DB response','API Response'],                       [dbDict[keys],"Not found"]]                result.tablelog(table, 'Results')            else:                #get API attribute Count                countAPIAttribute+=1                listDict=dbDict[keys]                for items in range(len(listDict)):                    if listDict[items]=='True':listDict[items]=True                    elif   listDict[items]=='False':listDict[items]=False                    else: listDict = map(str, listDict)                for items in range(len(parsed_json)):                    if parsed_json[items]=='True':parsed_json[items]=True                    elif parsed_json[items]=='False':parsed_json[items]=False                    elif  parsed_json[items]==True:pass                    elif  parsed_json[items]==False:pass                    else: parsed_json = [str(i).encode("utf-8").decode("utf-8") for i in parsed_json]                #parsed_json=[str(i).encode("utf-8").decode("utf-8") for i in parsed_json]                c=[x for x in parsed_json if x in list(listDict)]                compare = lambda x, y: collections.Counter(x) == collections.Counter(y)                if compare(parsed_json, c):                    pass                else:                    not_c=[x for x in parsed_json if x not in list(listDict)]                    print colored(('not equal','Attribute Name:'+keys,list(set(not_c))),'red')                result.equal(True, description="Expected DB Compare for Attribute: "+keys) (compare(parsed_json, c), name="Actual Db Compare")                if not compare(parsed_json, c):                    testResult.append('Fail')                table=[['DB response','API Response'],                       [listDict,parsed_json]]                result.tablelog(table, 'Results')            c=[]            listA=[ ]        else:            #get API attribute Count            countAPIAttribute+=1            listDict=dbDict[keys]            for items in range(len(listDict)):                if listDict[items]=='True':listDict[items]=True                elif   listDict[items]=='False':listDict[items]=False                else: listDict = map(str, listDict)                #listDict = " ".join(str(x) for x in listDict)            for items in range(len(parsed_json)):                if parsed_json[items]=='True':parsed_json[items]=True                elif   parsed_json[items]=='False':parsed_json[items]=False                elif  parsed_json[items]==True:pass                elif  parsed_json[items]==False:pass                else: parsed_json = [str(i).encode("utf-8").decode("utf-8") for i in parsed_json]            #parsed_json=[str(i).encode("utf-8").decode("utf-8") for i in parsed_json]            c=[x for x in parsed_json if x in list(listDict)]            compare = lambda x, y: collections.Counter(x) == collections.Counter(y)            if compare(parsed_json, c):                pass            else:                not_c=[x for x in parsed_json if x not in list(listDict)]                print colored(('not equal','Attribute Name:'+keys,list(set(not_c))),'red')            result.equal(True, description="Expected DB Compare for Attribute: "+keys) (compare(parsed_json, c), name="Actual Db Compare")            if not compare(parsed_json, c):                testResult.append('Fail')            table=[['DB response','API Response'],                   [listDict,parsed_json]]            result.tablelog(table, 'Results')        c=[]        listA=[]
    return   (countAPIAttribute, len(dbDict),testResult)

def find_values_nth_position(id,json_repr,nth):    AttributeNthValue = []    def _decode_dict(a_dict):        try: AttributeNthValue.append(a_dict[id])        except KeyError: pass        return a_dict    json.loads(json_repr, object_hook=_decode_dict)    return AttributeNthValue[nth]

@testsuiteclass API_validations(object):    def __init__(self,item):        self.item=item    def suite_name(self):        return "  '%s'" % (self.item)
    @testcase
    def API_validations(self, env,result):
        TestCaseResult=[]        domain,endpoint,method,urlparams,headers,requestbody,grn,DBdata,DBtextfile=get_domain_endpoint_method(self.item)        if endpoint is not None:            url = (domain+endpoint)        else:            url=domain        if(method=='GET'):            request_url,status_code,response_body,text,responsetime=GET(url,urlparams,headers,grn,result)        elif(method=='POST'):            request_url,status_code,response_body,text,responsetime=POST(url,urlparams,headers,requestbody,grn,result)            pass        else:            pass        logging.info('\t'+'\n'+'Request_url :'+str(request_url)                     +'\n'+'Status Code :'+str(status_code)                     +'\n'+'Response body:'+str(response_body)+'\n'+'Response Time:'+str(responsetime)+'\t')        logging.info(str(response_body))        logging.info(response_body)        result.log("Request_url :"+str(request_url))        result.log("Response Code :"+str(status_code))        result.log("Response Body :"+str(response_body))        result.log("Response Time :"+str(responsetime))        if status_code!=200:            TestCaseResult.append(self.item)            TestCaseResult.append('NA')            TestCaseResult.append('NA')            TestCaseResult.append('API error:Status Code'+' '+str(status_code))            table_data.append(TestCaseResult)            table=[['Test Case Name','API Attribute Count',"DB Attribute Count","TestCaseResult"],                   [self.item,'NA','NA','API down'+str(status_code)]]            result.tablelog(table, 'Final Results')        result.equal(200, description="Actual Response Code") (status_code, name="Expected Response Code")        if status_code==200:print colored("************API Response Success************* " +'\n','green')        if DBdata is not None and DBdata!='':            print colored("************Validating APi Response Across DB************* " +'\n','green')            dbDict=ExcelDbDataConversion(pathDB+'/'+DBdata)            try:                if response_body:                    totalApiAttributes,totalDBAttributes,testResult=ValidateDbData(dbDict,response_body,result)                    #*****************************Creating table data for HTML email report*************************************                    TestCaseResult.append(self.item)                    TestCaseResult.append(totalApiAttributes)                    TestCaseResult.append(totalDBAttributes)                    if len(testResult)>=1:testResult='Fail'                    elif totalApiAttributes!=totalDBAttributes:testResult='Fail'                    elif totalDBAttributes ==0:testResult='Fail'                    else:testResult='Pass'                    TestCaseResult.append(testResult)                    table_data.append(TestCaseResult)                    table=[['Test Case Name','API Attribute Count',"DB Attribute Count","TestCaseResult"],                           [self.item,totalApiAttributes,totalDBAttributes,testResult]]                    result.tablelog(table, 'Final Results')            except Exception as e:                print "No Response Body Found"+str(e)        else:            if DBtextfile is not None and DBtextfile!= '':                try:                    #pass                    Connect_run_DB_query(DBtextfile)                    #columnName,ColumnValues=Connect_run_DB_query(DBtextfile)                    #create_excelDb_for_validation(columnName,ColumnValues)                    dbDict=ExcelDbDataConversion(pathDB+'/DB.xlsx')                    try:                        if response_body:                            totalApiAttributes,totalDBAttributes,testResult=ValidateDbData(dbDict,response_body,result)                            #*****************************Creating table data for HTML email report*************************************                            TestCaseResult.append(self.item)                            TestCaseResult.append(totalApiAttributes)                            TestCaseResult.append(totalDBAttributes)                            if len(testResult)>=1:testResult='Fail'                            elif totalApiAttributes!=totalDBAttributes:testResult='Fail'                            elif totalDBAttributes ==0:testResult='Fail'                            else:testResult='Pass'                            TestCaseResult.append(testResult)                            table_data.append(TestCaseResult)                            table=[['Test Case Name','API Attribute Count',"DB Attribute Count","TestCaseResult"],                                   [self.item,totalApiAttributes,totalDBAttributes,testResult]]                            result.tablelog(table, 'Final Results')                    except Exception as e:                        print "No Response Body Found"+str(e)                except Exception as e :                    logging.error(str(e))                    print colored("************DB query couldnt be executed ************* " +'\n','red')
            else:                print colored("************DB query file not provided************* " +'\n','red')
            #print find_values_nth_position("id", text,0)
@test_plan(name='API Validation', description='API validation',database=testdb('testplan'))def main(plan,parser):
    parser.add_argument('--filepath',help='enter Config file location')    args=parser.parse_args()    if args.filepath is not None:        config.read(args.filepath+'/Config.ini')    else:        config.read(path+"/Config.ini")
    print colored("************API under Test************* " +'\n','green')    pattern='.*(?i)YES'    for item in config.sections():        if not item=='email':            try:                runmode=config.get(item,'runmode')            except:                pass            matchObj=re.match(pattern,runmode)            if matchObj:                plan.add( MultiTest( name='API Validation'+item,                                     description='API Validation_TestCase',                                     suites=API_validations(item),                                     environment=[] ))        else:            pass
if __name__=='__main__':    main()
# below code will be used to sent email with report:htmlcodeheader = HTML.table(    header_row = ['API vs DB Validation Result'],    width='100%',    col_align=[ 'center'],    col_styles=['background-color:lime'],    )
#created Regex to check for API responsepatternAPiDown=r'.*(?i)(API\s*error).*[(\w+)]'
result_colors = {    'Pass':      'lime',    'Fail':      'red',    'Error':      'yellow',}
#set Table colorfor test_id in sorted(table_data):    test_id[0]=HTML.TableCell(test_id[0], bgcolor='powderblue')    test_id[1]=HTML.TableCell(test_id[1], bgcolor='powderblue')    test_id[2]=HTML.TableCell(test_id[2], bgcolor='powderblue')    matchObjPattern=re.match(patternAPiDown,test_id[3])    colored_result = HTML.TableCell(test_id[3], bgcolor='yellow')    if matchObjPattern:test_id[3]=colored_result    # create the colored cell:    else:        color = result_colors[test_id[3]]        colored_result = HTML.TableCell(test_id[3], bgcolor=color)        # replace the column data in tabledata:        test_id[3]=colored_result
htmlcode = HTML.table(table_data,                      width='100%',                      header_row = ['TestCase', 'API attribute Count', 'DB attribute Count',  'Test Result' ],                      col_width=['1500px', '500px', '500px', '500px'],                      col_align=['center', 'center', 'center', 'char'],                      col_styles=['font-size: small','font-size: small', 'font-size: small', 'font-size: small'],                      )
msg = MIMEMultipart()rcptEmails=[]try:    msg['From']=config.get('email','From')    msg['To']=config.get('email','To')    msg['Subject']=config.get('email','Subject')    Toemails=config.get('email','To')    rcptEmails.extend(Toemails.split(','))    try:        msg['Bcc']=config.get('email','Bcc')        BCCemail=config.get('email','Bcc')        rcptEmails.extend(BCCemail.split(','))    except:        pass    try:        msg['Cc']=config.get('email','Cc')        CCemail=config.get('email','Cc')        rcptEmails.extend(CCemail.split(','))    except:        passexcept:   pass
print rcptEmailss = smtplib.SMTP('10.181.47.31')HTML_BODY = MIMEText(htmlcodeheader+htmlcode, 'html')
html = """\<html>  <head></head>  <body bgcolor="#E6E6FA">    <p>Regards,<br>       ASCDevOpsQA<br>    </p>  </body></html>"""htmlreport = MIMEText(htmlcodeheader+htmlcode+'\n'+html, 'html')msg.attach(htmlreport)msg.attach(HTML_BODY)#Below code can be used if we want to change the directory for report.html#pathreportHtml=os.path.abspath(os.path.join(os.path.dirname(__file__), '../'))#files = [f for f in os.listdir(pathreportHtml)]files = [f for f in os.listdir('.') if os.path.isfile(f)]for f in files:    if f=='report.html':        part = MIMEBase('application', "octet-stream")        part.set_payload( open(f,"rb").read() )        Encoders.encode_base64(part)        part.add_header('Content-Disposition', 'attachment; filename="{0}"'.format(os.path.basename(f)))        msg.attach(part)if  not msg['From'] or msg['To'] in msg.keys():    passelse:    print colored("****************Sending Email*************** ",'green')    s.sendmail(msg['From'],rcptEmails,msg.as_string())    s.quit()
